Syntax and Semantics
---

Parse tree structure must correspond to semantics of string generated (do what we intend)

syntax      semantics  
        ü§ù
    parse tree

---

OPERATOR - token to specify operation (+ and -) and operation itself

OPERANDS - input
    unary: -1 (prefix)
            a++ (postfix)
    binary: 1 + 2 (infix)
            + 1 2 (prefix)
            1 2 + (postfix)
    ternary: a?b:c

---

PRECEDENCE of operators
    used when order of eval not clear with ( )
    higher performed first
    * before + so a+b*c = a+(b*c)

G4: <exp> ::= <exp> + <exp>
                | <exp> * <exp> 
                | <exp>
                | a | b | c

becomes now

G5: <exp> ::= <exp> + <exp> | <mulexp>
    <mulexp> :: = <exp> * <exp> 
                | (<exp>)
                | a | b | c

---

ASSOCIATIVITY of operators
    left :  a+b+c+d = ((a+b)+c)+d   [common]
    right : a+b+c+d = a+(b+(c+d))

left associative:
    <expr> ::= <expr> + <other> | <other>
rigth associative:
    <expr> ::= <other> + <expr> | <other>

G6: <exp> ::= <exp> + <mulexp> | <mulexp>
    <mulexp> :: = <mulexp> * <rootexp> | <rootexp>
    <rootexp> ::= (<exp>)
                | a | b | c

---

ambiguity from DANGLING ELSE

<stmt> ::= <if-stmt> | s1 | s2
<if-stmt> ::= if <expr> then <stmt> else <stmt>
            | if <expr> then <stmt>
<expr> ::= e1 | e2

wtf does this mean?
    if e1 then if e2 then s1 else s2

FiX this with <full-stmt> that generates everything <stmt> generates, except that it can not generate if statements with no else: 

<stmt> ::= <if-stmt> | s1 | s2
<if-stmt> ::= if <expr> then <full-stmt> else <stmt>
            | if <expr> then <stmt>
<expr> ::= e1 | e2
<full-stmt> ::= <full-if> | s1 | s2
<full-if> ::= if <expr> then <full-stmt> else <full-stmt>

unclear dangling if-then-else
    Python makes nested if statements to be indented

---

CLUTTER - when we make grammar clearer, it becomes harder to read with more productions and nonterminals
    Tools (parsers, generators) need ambiguity eliminated
    People want more readable grammar
        We can leave ambiguity but write text explaining how stuff will be parsed

---

EBNF and Parse Trees

    <exp> ::= <mulexp> {+ <mulexp>} 

    What parse tree for a+a+a?

    You can:
    (1)     Use {} anywhere it helps 
    (2)     Define a convention: for example, that the form <exp> ::= <mulexp> {+ <mulexp>} will be used only for left-associative operators 
            Explicitly recursive rules for whack shit like <expa> ::= <expb> [ = <expa> ] 

---

ABSTRACT SYNTAX TREE - abbreviated version of parse tree
    Node for every operation, subtree for every operand 

When language parses a program, it makes an AST not full parse tree in memory