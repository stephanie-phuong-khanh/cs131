OCaml discriminated union
Ocaml union is safer because you can't misinterpret the type
 ______________________________________
| type flag |         64 bit           |


in C,C++:
    union u { long l; char *p };    u.l and u.p have the same address
    union u v;

        v.l = -12;
        v.p = "abc"; // v.l has unspecified value

    int f (union u a) {
        is a.l valid, or a.p? f cannot tell.
    }

in OCaml you can tell.
    type u =
        | I of int
        | S of string

    One way to think of this, is that a u value is represented by piece of storage, that not only has enough room to hold the int or string (as in C/C++) but also has an extra bit of room to hold a type tag.

    type mytype =
        | Foo
        | Bar of int
        | Baz of int * int
    we now have three constructors to assumble mytype values
        Foo
        Bar 12  returns new mytype value with type field Bar and value 12
        Baz (3,5)
    they can also be used in patterns, to disassemble mytype values
        match myvalue with 
            | Foo -> 0
            | Bar x -> x
            | Baz (y,z) -> y+z
    
    These unions can be generic. Option is name of the type. a' or ('a, 'b) makes it generic
        type 'a option = 
            | None
            | Some of 'a
        ________
        | None |
        ____________________
        | Some |    'a     |

        (None)                  // 'a option
        (Some "abc")            // string option
    Here we have a safer version of the null pointer. In C/C++ we have char * as pointer to sequence of bytes, OR it's NULL. Later if we have strcmp(p,"abc"), program will crash in C if p==NULL. In OCaml, this cannot happen because we don't have an idea of Null pointer. 
            (generic type that is recursive -> make list)
        type 'a sequence =
            | Empty
            | Nonempty of 'a * ('a sequence)

            (handwavy)
        type 'a list =
            | []
            | 'a :: 'a list

    
FUNCTIONS AND CURRYING

        (long version)
    fun x -> fun y -> x*x + y

        (short version)
    fun x y -> x*x + y

FUNCTIONS AND PATTERNS
        (long version)
    fun x -> match x with 
            | None -> 0
            | Some y -> y

        (short version)
    function
        | None -> 0
        | Some y -> y

You can mix the two, but be careful.

    let car (h::_) -> h             // questionable way
    let car = (fun (h::_) -> h)
    let car = (fun x -> match x with (h::_) -> h)
    
Simple recusive function: reverse a list

    let rec reverse = function
                    | [] -> []
                    | h::t -> (reverse t)@h;;

    There is an error in our function because it's type ('a list list -> 'a list)
    val reverse : 'a list list -> 'a list = <fun>

        (fix)
    let rec reverse = function
                    | [] -> []
                    | h::t -> (reverse t)@[h];;

By default, OCaml says you must define something before using it.

    let x = x*x     is not allowed! You can't define x in terms of itself.
    

